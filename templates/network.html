{% extends "layout.html" %}
{% block content %}
<div class="flex flex-col md:flex-row gap-6">
  <div class="flex-1 bg-gray-900/60 backdrop-blur-xl rounded-2xl border border-gray-800 p-6 relative overflow-hidden">
    <h2 class="text-lg font-semibold text-accent mb-4">Network Map</h2>
    <canvas id="networkCanvas" class="w-full h-[500px] rounded-2xl bg-gray-950"></canvas>
  </div>

  <div class="w-full md:w-80 bg-gray-900/70 backdrop-blur-xl rounded-2xl border border-gray-800 p-6">
    <h3 class="text-accent font-semibold mb-4">Device Info</h3>
    <div id="deviceInfo" class="text-gray-400 space-y-2">
      <p>Select a device on the map ðŸ‘‡</p>
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById('networkCanvas');
  const ctx = canvas.getContext('2d');
  const devices = [
    { name: "Router", x: 300, y: 250, color: "#00C6FF", info: "Main Gateway - 192.168.1.1" },
    { name: "Laptop", x: 150, y: 400, color: "#4ade80", info: "Laptop - 192.168.1.23" },
    { name: "Phone", x: 480, y: 420, color: "#facc15", info: "Smartphone - 192.168.1.45" },
    { name: "Camera", x: 420, y: 120, color: "#f87171", info: "Security Camera - 192.168.1.55" }
  ];

  const links = [
    [0,1],[0,2],[0,3]
  ];

  function normalizeDevices() {
    const w = canvas.clientWidth || canvas.offsetWidth;
    const h = canvas.clientHeight || canvas.offsetHeight;
    devices.forEach(d => {
      d._rx = (d.x !== undefined) ? (d.x / w) : (d._rx || 0.5);
      d._ry = (d.y !== undefined) ? (d.y / h) : (d._ry || 0.5);
    });
  }

  function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const w = canvas.offsetWidth;
    const h = canvas.offsetHeight;
    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    normalizeDevices();
    drawNetwork();
  }

  let resizeScheduled = false;
  window.addEventListener('resize', () => {
    if (!resizeScheduled) {
      resizeScheduled = true;
      requestAnimationFrame(() => { resizeCanvas(); resizeScheduled = false; });
    }
  });

  resizeCanvas();

  function drawNetwork() {
    ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
    ctx.strokeStyle = "#1e293b";
    ctx.lineWidth = 2;
    for (const [a, b] of links) {
      const d1 = devices[a];
      const d2 = devices[b];
      const x1 = (d1._rx || 0.5) * canvas.clientWidth;
      const y1 = (d1._ry || 0.5) * canvas.clientHeight;
      const x2 = (d2._rx || 0.5) * canvas.clientWidth;
      const y2 = (d2._ry || 0.5) * canvas.clientHeight;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    for (const device of devices) {
      const dx = (device._rx || 0.5) * canvas.clientWidth;
      const dy = (device._ry || 0.5) * canvas.clientHeight;
      const gradient = ctx.createRadialGradient(dx, dy, 5, dx, dy, 25);
      gradient.addColorStop(0, device.color);
      gradient.addColorStop(1, "transparent");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(dx, dy, 12, 0, Math.PI * 2);
      ctx.fill();
      device._drawX = dx;
      device._drawY = dy;
    }
  }


  canvas.addEventListener("click", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    for (const device of devices) {
      const dx = mouseX - (device._drawX || (device.x || 0));
      const dy = mouseY - (device._drawY || (device.y || 0));
      if (Math.sqrt(dx * dx + dy * dy) < 20) {
        document.getElementById("deviceInfo").innerHTML = `
          <h4 class="text-white font-semibold">${device.name}</h4>
          <p class="text-gray-400">${device.info}</p>
        `;
      }
    }
  });
</script>
{% endblock %}
