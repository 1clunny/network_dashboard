{% extends "layout.html" %}
{% block content %}

<div class="flex flex-col gap-6">
  <!-- Animated Network -->
  <div class="bg-gray-900/60 backdrop-blur-xl rounded-2xl border border-gray-800 p-6 relative overflow-hidden">
    <h2 class="text-lg font-semibold text-accent mb-4">Animated Network Map</h2>
    <canvas id="animatedCanvas" class="w-full h-[400px] rounded-2xl bg-gray-950"></canvas>
  </div>

  <!-- Device List -->
  <div class="bg-gray-900/70 backdrop-blur-xl rounded-2xl border border-gray-800 p-6">
    <h2 class="text-lg font-semibold text-accent mb-4">Device Overview</h2>
    <div id="deviceList" class="grid grid-cols-2 md:grid-cols-4 gap-4 text-gray-300">
      <!-- Device buttons will go here -->
    </div>
  </div>

  <!-- Sidebar Info -->
  <div class="w-full bg-gray-900/70 backdrop-blur-xl rounded-2xl border border-gray-800 p-6">
    <h3 class="text-accent font-semibold mb-4">Device Info</h3>
    <div id="deviceInfo" class="text-gray-400 space-y-2">
      <p>Select a device on the map or from the list ðŸ‘‡</p>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("animatedCanvas");
const ctx = canvas.getContext("2d");
const infoBox = document.getElementById("deviceInfo");
const deviceListContainer = document.getElementById("deviceList");

// Devices
const devices = [
  { name: "Router", x: 300, y: 150, dx: 0.25, dy: 0.2, color: "#00C6FF", info: "Main Gateway â€¢ 192.168.1.1" },
  { name: "Laptop", x: 150, y: 300, dx: -0.2, dy: 0.18, color: "#22c55e", info: "Laptop â€¢ 192.168.1.23" },
  { name: "Phone", x: 480, y: 320, dx: 0.22, dy: -0.25, color: "#facc15", info: "Smartphone â€¢ 192.168.1.45" },
  { name: "Camera", x: 420, y: 100, dx: -0.18, dy: 0.2, color: "#ef4444", info: "Security Cam â€¢ 192.168.1.55" },
];

const links = [
  [0,1],[0,2],[0,3]
];

let selected = null;
let clickEffects = [];

// Normalize positions and speeds into ratios so layout remains proportional
function normalizeAnimated() {
  const w = canvas.clientWidth || canvas.offsetWidth;
  const h = canvas.clientHeight || canvas.offsetHeight;
  devices.forEach(d => {
    // establish or preserve normalized ratios for position
    if (d._rx === undefined || d._ry === undefined) {
      d._rx = (d.x !== undefined) ? (d.x / w) : 0.5;
      d._ry = (d.y !== undefined) ? (d.y / h) : 0.5;
    }
    // speeds become normalized per-frame ratios (recompute on each normalize so resize adjusts velocities)
    d._rdx = (d.dx !== undefined) ? (d.dx / w) : 0;
    d._rdy = (d.dy !== undefined) ? (d.dy / h) : 0;
    // compute current display coords immediately so the UI updates during resize
    d.x = (d._rx || 0.5) * w;
    d.y = (d._ry || 0.5) * h;
  });
}

// Make canvas responsive
// DPR-aware resize so canvas stays crisp on HiDPI displays
function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.offsetWidth;
  const h = canvas.offsetHeight;
  canvas.width = Math.max(1, Math.floor(w * dpr));
  canvas.height = Math.max(1, Math.floor(h * dpr));
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  // On resize, preserve normalized positions and recompute speeds
  normalizeAnimated();
  // also render one immediate frame so devices update during resize
  renderAnimatedFrame();
}

// Throttle resize with rAF to avoid repeated heavy work
let resizeScheduled = false;
function scheduleResize() {
  if (!resizeScheduled) {
    resizeScheduled = true;
    requestAnimationFrame(() => { resizeCanvas(); resizeScheduled = false; });
  }
}
window.addEventListener("resize", scheduleResize);

// initial setup
resizeCanvas();

// Use ResizeObserver for more reliable size updates while the window is being dragged/resized
if (typeof ResizeObserver !== 'undefined') {
  const ro = new ResizeObserver(() => {
    scheduleResize();
    // also force an immediate single-frame render so devices reposition during drag
    renderAnimatedFrame();
  });
  // observe the canvas itself so actual drawing area changes trigger updates
  ro.observe(canvas);
}

// Draw a single device
function drawDevice(ctx, device, radius = 10, glow = true) {
  const x = device.x;
  const y = device.y;
  if (glow) {
    const gradient = ctx.createRadialGradient(x, y, 3, x, y, radius * 2);
    gradient.addColorStop(0, device.color);
    gradient.addColorStop(1, "transparent");
    ctx.fillStyle = gradient;
  } else {
    ctx.fillStyle = device.color;
  }
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "#94a3b8";
  ctx.font = "12px Inter, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(device.name, x, y + radius + 12);
}

// Render a single frame of the animated network (no scheduling)
function renderAnimatedFrame() {
  // clear using CSS pixel sizes since we've set a transform for DPR
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);

  // Lines
  for (const [a, b] of links) {
    const d1 = devices[a], d2 = devices[b];
    const gradient = ctx.createLinearGradient(d1.x, d1.y, d2.x, d2.y);
    gradient.addColorStop(0, "rgba(0,198,255,0.25)");
    gradient.addColorStop(1, "rgba(0,198,255,0.05)");
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(d1.x, d1.y);
    ctx.lineTo(d2.x, d2.y);
    ctx.stroke();
  }

  // Move & draw devices (using normalized ratios so they stay proportional)
  for (const device of devices) {
    // update normalized positions
    device._rx += device._rdx;
    device._ry += device._rdy;

    // compute display positions
    device.x = device._rx * canvas.clientWidth;
    device.y = device._ry * canvas.clientHeight;

    // bounce on edges (use CSS pixel sizes)
    if (device.x < 15 || device.x > canvas.clientWidth - 15) device._rdx *= -1;
    if (device.y < 15 || device.y > canvas.clientHeight - 15) device._rdy *= -1;

    drawDevice(ctx, device, 10);
  }

  // Click effects
  for(let i=clickEffects.length-1;i>=0;i--){
    const e = clickEffects[i];
    ctx.beginPath();
    ctx.strokeStyle = e.color+"88";
    ctx.lineWidth = 2;
    ctx.arc(e.x,e.y,e.radius,0,Math.PI*2);
    ctx.stroke();
    e.radius += 2;
    e.opacity -= 0.02;
    if(e.opacity<=0) clickEffects.splice(i,1);
  }
}

// Main loop schedules frames
function drawAnimated() {
  renderAnimatedFrame();
  requestAnimationFrame(drawAnimated);
}

// Click handler for canvas
canvas.addEventListener("click",(e)=>{
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;

  for (const device of devices) {
    const dx = mouseX - device.x, dy = mouseY - device.y;
    if (Math.sqrt(dx * dx + dy * dy) < 12) {
      selected = device;
      infoBox.innerHTML = `<p><strong>${device.name}</strong></p><p>${device.info}</p>`;
      clickEffects.push({ x: device.x, y: device.y, radius: 10, color: device.color, opacity: 1 });
      break;
    }
  }
});

// Build static device list
function buildDeviceList(){
  deviceListContainer.innerHTML = "";
  devices.forEach((d,i)=>{
    const btn = document.createElement("button");
    btn.className = "bg-gray-800 hover:bg-gray-700 rounded-lg p-2 text-left cursor-pointer transition-colors";
    btn.innerHTML = `<span class="font-semibold">${d.name}</span><br><span class="text-sm text-gray-400">${d.info}</span>`;
    btn.addEventListener("click",()=>{
      selected=d;
      infoBox.innerHTML = `<p><strong>${d.name}</strong></p><p>${d.info}</p>`;
      clickEffects.push({x:d.x, y:d.y, radius:10, color:d.color, opacity:1});
    });
    deviceListContainer.appendChild(btn);
  });
}

buildDeviceList();
drawAnimated();
</script>

{% endblock %}