{% extends "layout.html" %}
{% block content %}

<div class="flex flex-col md:flex-row gap-6 min-h-[60vh] md:min-h-[calc(100vh-4rem)] items-stretch">
  <!-- Device Status Graph -->
  <div class="flex-1 bg-gray-900/60 backdrop-blur-xl rounded-2xl border border-gray-800 p-6 relative overflow-hidden">
    <h2 class="text-lg font-semibold text-accent mb-4">Device Status Graph</h2>
    <div id="radialWrap" class="mt-4 relative flex items-center justify-center">
      <svg id="radialSvg" viewBox="0 0 500 500" class="w-full h-auto max-h-[720px]"></svg>
      <div id="radialTooltip" class="pointer-events-none absolute z-50 hidden bg-black text-white text-sm py-1 px-2 rounded-md shadow-lg" style="transform: translate(-50%, -120%);"></div>
    </div>
  </div>

  <!-- (Device Overview removed to make chart larger) -->

  <!-- Sidebar Info -->
  <div class="w-full md:w-80 bg-gray-900/70 backdrop-blur-xl rounded-2xl border border-gray-800 p-6 self-stretch h-full">
    <h3 class="text-accent font-semibold mb-4">Device Info</h3>
    <div id="deviceInfo" class="text-gray-400 space-y-2">
      <p>Click any node on the graph to view device details ðŸ‘‡</p>
    </div>
  </div>
</div>

<script>
const infoBox = document.getElementById("deviceInfo");
const svg = document.getElementById('radialSvg');

// Devices with status (expanded list for better visualization)
const devices = [
  { name: "Router", status: "connected", ip: "192.168.1.1", color: "#16a34a" },
  { name: "Laptop A", status: "connected", ip: "192.168.1.23", color: "#22c55e" },
  { name: "Laptop B", status: "connected", ip: "192.168.1.24", color: "#22c55e" },
  { name: "Desktop A", status: "connected", ip: "192.168.1.25", color: "#059669" },
  { name: "Phone A", status: "connected", ip: "192.168.1.45", color: "#10b981" },
  { name: "Tablet", status: "idle", ip: "192.168.1.46", color: "#facc15" },
  { name: "Phone B", status: "idle", ip: "192.168.1.47", color: "#f59e0b" },
  { name: "Printer", status: "idle", ip: "192.168.1.60", color: "#fbbf24" },
  { name: "Camera 1", status: "off", ip: "192.168.1.55", color: "#ef4444" },
  { name: "Camera 2", status: "off", ip: "192.168.1.56", color: "#dc2626" },
  { name: "IoT Sensor", status: "connected", ip: "192.168.1.70", color: "#34d399" },
  { name: "NAS", status: "connected", ip: "192.168.1.90", color: "#059669" },
  { name: "Guest Phone", status: "idle", ip: "192.168.1.120", color: "#f59e0b" },
  { name: "Smart Light", status: "off", ip: "192.168.1.200", color: "#ef4444" }
];

function showDevice(d) {
  infoBox.innerHTML = `
    <p class="text-sm text-gray-400">Status: <span class="font-semibold text-white">${d.status}</span></p>
    <h4 class="text-white font-semibold mt-2">${d.name}</h4>
    <p class="text-gray-400">${d.ip}</p>
  `;
}

// tooltip helpers for radial chart nodes
const tooltipEl = document.getElementById('radialTooltip');
const radialWrap = document.getElementById('radialWrap');
function showTooltip(ev, text) {
  if (!tooltipEl) return;
  tooltipEl.textContent = text;
  tooltipEl.style.display = 'block';
  // position relative to radialWrap
  const rect = radialWrap.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  tooltipEl.style.left = x + 'px';
  tooltipEl.style.top = (y - 12) + 'px';
}
function hideTooltip() {
  if (!tooltipEl) return;
  tooltipEl.style.display = 'none';
}

// Radial donut chart renderer
function polarToCartesian(cx, cy, r, angleDeg) {
  const a = (angleDeg - 90) * Math.PI / 180.0;
  return { x: cx + (r * Math.cos(a)), y: cy + (r * Math.sin(a)) };
}

function describeArc(cx, cy, r, startAngle, endAngle) {
  const start = polarToCartesian(cx, cy, r, endAngle);
  const end = polarToCartesian(cx, cy, r, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
  return [`M ${start.x} ${start.y}`, `A ${r} ${r} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`].join(' ');
}

function describeSector(cx, cy, r, startAngle, endAngle) {
  const start = polarToCartesian(cx, cy, r, endAngle);
  const end = polarToCartesian(cx, cy, r, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
  // Move to center, line to start, arc to end, back to center
  return `M ${cx} ${cy} L ${start.x} ${start.y} A ${r} ${r} 0 ${largeArcFlag} 0 ${end.x} ${end.y} Z`;
}

// simple inline icon generator (returns an SVG <g> element)
function getDeviceIcon(device, size = 22) {
  const g = document.createElementNS('http://www.w3.org/2000/svg','g');
  g.setAttribute('width', size); g.setAttribute('height', size);
  g.style.pointerEvents = 'auto'; // allow events
  const name = (device.name || '').toLowerCase();
  // helper to create shapes
  const rect = (x,y,w,h,rx,fill,stroke) => {
    const r = document.createElementNS('http://www.w3.org/2000/svg','rect');
    r.setAttribute('x', x); r.setAttribute('y', y); r.setAttribute('width', w); r.setAttribute('height', h);
    if (rx) { r.setAttribute('rx', rx); r.setAttribute('ry', rx); }
    if (fill) r.setAttribute('fill', fill);
    if (stroke) { r.setAttribute('stroke', stroke); r.setAttribute('stroke-width', 1); }
    return r;
  };
  const circ = (cx_,cy_,r_,fill,stroke) => {
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx', cx_); c.setAttribute('cy', cy_); c.setAttribute('r', r_);
    if (fill) c.setAttribute('fill', fill);
    if (stroke) { c.setAttribute('stroke', stroke); c.setAttribute('stroke-width', 1); }
    return c;
  };

  // scale factors for a 22px grid
  const s = size / 22;
  if (name.includes('phone') || name.includes('tablet')) {
    // phone vs tablet: narrow phone, wider tablet
    if (name.includes('tablet')) {
      // tablet: larger rounded rectangle with small camera dot
      g.appendChild(rect(1.5*s,1.5*s,19*s,19*s,3*s,'#ffffff',device.color));
      g.appendChild(circ(17.5*s,3.5*s,1.2*s,device.color));
    } else {
      // phone: taller narrow rounded rectangle with a home button
      g.appendChild(rect(5*s,1.8*s,12*s,18.4*s,3*s,'#ffffff',device.color));
      g.appendChild(circ(11*s,18*s,1.2*s,device.color));
    }
  } else if (name.includes('laptop') || name.includes('desktop') || name.includes('pc')) {
    // laptop vs desktop
    if (name.includes('laptop')) {
      // laptop: screen + keyboard/base
      g.appendChild(rect(1.5*s,3*s,19*s,12*s,2*s,'#ffffff',device.color));
      g.appendChild(rect(4*s,15.8*s,14*s,2.8*s,1*s,'#f7fafc',device.color));
    } else {
      // desktop: monitor with stand and a small tower box
      g.appendChild(rect(2.5*s,2.5*s,17*s,11.5*s,2*s,'#ffffff',device.color));
      g.appendChild(rect(9*s,14.5*s,4*s,1.8*s,0.8*s,'#f7fafc',device.color));
      g.appendChild(rect(1.8*s,4*s,3.6*s,9*s,1*s,'#ffffff',device.color));
      g.appendChild(rect(1.8*s,4*s,3.6*s,9*s,1*s,'#ffffff',device.color));
      // tower indicator lines
      g.appendChild(rect(2.8*s,5.6*s,1.2*s,0.8*s,0.6*s,device.color));
      g.appendChild(rect(2.8*s,7.6*s,1.2*s,0.8*s,0.6*s,device.color));
    }
  } else if (name.includes('camera')) {
    // camera: rounded rect with lens circle
    g.appendChild(rect(2*s,3*s,18*s,14*s,3*s,'#ffffff',device.color));
    g.appendChild(circ(12*s,10*s,4*s,device.color,'#000'));
  } else if (name.includes('router') || name.includes('nas') || name.includes('printer')) {
    // box with small indicators
    g.appendChild(rect(2*s,4*s,18*s,12*s,2*s,'#ffffff',device.color));
    g.appendChild(circ(7*s,9*s,1.1*s,device.color));
    g.appendChild(circ(10*s,9*s,1.1*s,device.color));
    g.appendChild(circ(13*s,9*s,1.1*s,device.color));
  } else if (name.includes('light') || name.includes('bulb')) {
    // lightbulb icon: circle bulb + filament + base
    g.appendChild(circ(11*s,8.5*s,6.2*s,'#ffffff',device.color));
    const fil = document.createElementNS('http://www.w3.org/2000/svg','path');
    fil.setAttribute('d', `M ${11*s-2.5*s} ${8.5*s} q ${2*s} ${-2*s} ${5*s} 0`);
    fil.setAttribute('stroke', device.color); fil.setAttribute('fill','none'); fil.setAttribute('stroke-width',1.2);
    g.appendChild(fil);
    g.appendChild(rect(8.8*s,13.2*s,4.4*s,2.4*s,0.6*s,'#f7fafc',device.color));
  } else if (name.includes('iot') || name.includes('sensor')) {
    // small sensor: circle with dot
    g.appendChild(circ(11*s,11*s,8*s,'#ffffff',device.color));
    g.appendChild(circ(11*s,11*s,3*s,device.color));
  } else {
    // fallback: small rounded box
    g.appendChild(rect(2*s,3*s,18*s,14*s,3*s,'#ffffff',device.color));
  }

  return g;
}

function renderRadialChart(progress = 1) {
  // clear
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  const w = 500, h = 500;
  const cx = w/2, cy = h/2;
  const r = 120;
  const ringWidth = 120;

  // defs: gradients and shadow
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const shadow = document.createElementNS('http://www.w3.org/2000/svg','filter');
  shadow.setAttribute('id','dropShadow');
  // enlarge filter region so blur doesn't get clipped and use feDropShadow for a softer circular shadow
  shadow.setAttribute('x','-50%'); shadow.setAttribute('y','-50%'); shadow.setAttribute('width','200%'); shadow.setAttribute('height','200%');
  shadow.innerHTML = `<feDropShadow dx="0" dy="3" stdDeviation="4" flood-color="#000" flood-opacity="0.18"/>`;
  defs.appendChild(shadow);

  // gradients for statuses
  const gConnected = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
  gConnected.setAttribute('id','gradConnected'); gConnected.setAttribute('x1','0%'); gConnected.setAttribute('x2','100%');
  gConnected.innerHTML = `<stop offset="0%" stop-color="#22c55e" stop-opacity="0.95"/><stop offset="100%" stop-color="#10b981" stop-opacity="0.95"/>`;
  defs.appendChild(gConnected);
  const gIdle = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
  gIdle.setAttribute('id','gradIdle'); gIdle.innerHTML = `<stop offset="0%" stop-color="#facc15"/><stop offset="100%" stop-color="#f59e0b"/>`;
  defs.appendChild(gIdle);
  const gOff = document.createElementNS('http://www.w3.org/2000/svg','linearGradient');
  gOff.setAttribute('id','gradOff'); gOff.innerHTML = `<stop offset="0%" stop-color="#ef4444"/><stop offset="100%" stop-color="#dc2626"/>`;
  defs.appendChild(gOff);
  svg.appendChild(defs);
  // Use a modern system/Inter fallback font for SVG text
  try { svg.style.fontFamily = 'Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif'; } catch(e) {}

  const statuses = [
    { key: 'connected', color: 'url(#gradConnected)', base: '#22c55e' },
    { key: 'idle', color: 'url(#gradIdle)', base: '#facc15' },
    { key: 'off', color: 'url(#gradOff)', base: '#ef4444' }
  ];

  const counts = statuses.map(s => devices.filter(d => d.status === s.key).length);
  const total = devices.length || 1;

  // draw filled pie sectors (animated by progress)
  let angleStart = 0;
  statuses.forEach((s, idx) => {
    const pct = counts[idx]/total;
    const fullAngle = pct * 360;
    const angle = fullAngle * progress; // animated portion
    if (pct <= 0) { angleStart += fullAngle; return; }
    const start = angleStart;
    const end = angleStart + angle;
    // draw sector (full pie)
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', describeSector(cx, cy, r + ringWidth/2, start, end));
    path.setAttribute('fill', s.color);
    path.setAttribute('filter', 'url(#dropShadow)');
    path.setAttribute('opacity', '0.98');
    path.style.cursor = 'pointer';
    // hover effect
    path.addEventListener('mouseenter', () => path.setAttribute('opacity','1'));
    path.addEventListener('mouseleave', () => path.setAttribute('opacity','0.98'));
    path.addEventListener('click', () => showDevicesByStatus(s.key));
    svg.appendChild(path);

    // label percent at middle of full span (use fullAngle to place percent for readability)
    const mid = start + fullAngle/2;
    const labelPos = polarToCartesian(cx, cy, r - 20, mid);
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', labelPos.x); text.setAttribute('y', labelPos.y);
    // darker/bolder letters
    text.setAttribute('fill','#0b1220'); text.setAttribute('font-size','13'); text.setAttribute('font-weight','800'); text.setAttribute('text-anchor','middle');
    text.textContent = `${Math.round(pct*100)}%`;
    svg.appendChild(text);

    // place devices for this status evenly within full span (always use full span positions)
    const groupDevices = devices.filter(d => d.status === s.key);
    groupDevices.forEach((d,i) => {
      const slotAngle = start + (fullAngle * (i + 0.5) / Math.max(1, groupDevices.length));
      // place chips inside the filled sector (closer to the middle of the sector)
      const nodeRadius = r + Math.round(ringWidth/4); // inside the pie
      const nodePos = polarToCartesian(cx, cy, nodeRadius, slotAngle);

      // create an icon group and place it at nodePos
      const iconSize = 28; // slightly larger so icons are comfortable
      const icon = getDeviceIcon(d, iconSize);
      // position the icon group so its center is at nodePos
      const tx = nodePos.x - (iconSize/2);
      const ty = nodePos.y - (iconSize/2);
      icon.setAttribute('transform', `translate(${tx},${ty})`);
      icon.style.cursor = 'pointer';
      icon.setAttribute('filter','url(#dropShadow)');
      // interactions
      icon.addEventListener('click', () => showDevice(d));
      icon.addEventListener('mouseenter', (ev) => { icon.setAttribute('transform', `translate(${tx},${ty-4})`); showTooltip(ev, `${d.name} â€” ${d.status}`); });
      icon.addEventListener('mousemove', (ev) => showTooltip(ev, `${d.name} â€” ${d.status}`));
      icon.addEventListener('mouseleave', () => { icon.setAttribute('transform', `translate(${tx},${ty})`); hideTooltip(); });
      svg.appendChild(icon);
    });

    angleStart += fullAngle;
  });

  // center label
  const centerText = document.createElementNS('http://www.w3.org/2000/svg','text');
  centerText.setAttribute('x', cx); centerText.setAttribute('y', cy + 6);
  centerText.setAttribute('fill','#0b1220'); centerText.setAttribute('font-size','18'); centerText.setAttribute('font-weight','800'); centerText.setAttribute('text-anchor','middle');
  centerText.textContent = total + ' Devices';
  svg.appendChild(centerText);
}

// animate chart from 0->1
function animateRadial(duration = 700) {
  const start = performance.now();
  function frame(now) {
    const t = Math.min(1, (now - start) / duration);
    // easeOutCubic
    const p = 1 - Math.pow(1 - t, 3);
    renderRadialChart(p);
    if (t < 1) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

// initial render and handlers
animateRadial();
window.addEventListener('resize', () => animateRadial(300));

// show a list of devices for a given status (used when clicking a sector)
function showDevicesByStatus(statusKey) {
  const mapping = {
    connected: 'Devices â€” On',
    idle: 'Devices â€” Idle',
    off: 'Devices â€” Off'
  };
  const list = devices.filter(d => d.status === statusKey);
  if (!list.length) {
    infoBox.innerHTML = `<p class="text-sm text-gray-400">No devices for <span class="font-semibold text-white">${mapping[statusKey]||statusKey}</span></p>`;
    return;
  }
  let html = `<h4 class=\"text-white font-semibold\">${mapping[statusKey]||statusKey} (${list.length})</h4>`;
  html += '<ul class="text-gray-400 mt-2 space-y-1">';
  list.forEach(d => {
    html += `<li class=\"flex justify-between items-center\"><span class=\"font-medium text-white\">${d.name}</span><span class=\"text-gray-400 text-sm\">${d.ip}</span></li>`;
  });
  html += '</ul>';
  infoBox.innerHTML = html;
}
</script>

{% endblock %}