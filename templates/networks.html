{% extends "layout.html" %}
{% block content %}

<div class="flex flex-col md:flex-row gap-6 min-h-[60vh] md:min-h-[calc(100vh-4rem)] items-stretch">
  <!-- Device Status Graph -->
  <div class="flex-1 bg-gray-900/60 backdrop-blur-xl rounded-2xl border border-gray-800 p-6 relative overflow-hidden">
    <h2 class="text-lg font-semibold text-accent mb-4">Device Status Graph</h2>
    <div id="radialWrap" class="mt-4 flex items-center justify-center">
      <svg id="radialSvg" viewBox="0 0 500 500" class="w-full h-auto max-h-[720px]"></svg>
    </div>
  </div>

  <!-- (Device Overview removed to make chart larger) -->

  <!-- Sidebar Info -->
  <div class="w-full md:w-80 bg-gray-900/70 backdrop-blur-xl rounded-2xl border border-gray-800 p-6 self-stretch h-full">
    <h3 class="text-accent font-semibold mb-4">Device Info</h3>
    <div id="deviceInfo" class="text-gray-400 space-y-2">
      <p>Click any node on the graph to view device details ðŸ‘‡</p>
    </div>
  </div>
</div>

<script>
const infoBox = document.getElementById("deviceInfo");
const svg = document.getElementById('radialSvg');

// Devices with status
const devices = [
  { name: "Router", status: "connected", ip: "192.168.1.1", color: "#00C6FF" },
  { name: "Laptop", status: "connected", ip: "192.168.1.23", color: "#22c55e" },
  { name: "Phone", status: "idle", ip: "192.168.1.45", color: "#facc15" },
  { name: "Camera", status: "off", ip: "192.168.1.55", color: "#ef4444" },
];

function showDevice(d) {
  infoBox.innerHTML = `
    <p class="text-sm text-gray-400">Status: <span class="font-semibold text-white">${d.status}</span></p>
    <h4 class="text-white font-semibold mt-2">${d.name}</h4>
    <p class="text-gray-400">${d.ip}</p>
  `;
}

// Radial donut chart renderer
function polarToCartesian(cx, cy, r, angleDeg) {
  const a = (angleDeg - 90) * Math.PI / 180.0;
  return { x: cx + (r * Math.cos(a)), y: cy + (r * Math.sin(a)) };
}

function describeArc(cx, cy, r, startAngle, endAngle) {
  const start = polarToCartesian(cx, cy, r, endAngle);
  const end = polarToCartesian(cx, cy, r, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
  return [`M ${start.x} ${start.y}`, `A ${r} ${r} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`].join(' ');
}

function describeSector(cx, cy, r, startAngle, endAngle) {
  const start = polarToCartesian(cx, cy, r, endAngle);
  const end = polarToCartesian(cx, cy, r, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';
  // Move to center, line to start, arc to end, back to center
  return `M ${cx} ${cy} L ${start.x} ${start.y} A ${r} ${r} 0 ${largeArcFlag} 0 ${end.x} ${end.y} Z`;
}

function renderRadialChart(progress = 1) {
  // clear
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  const w = 500, h = 500;
  const cx = w/2, cy = h/2;
  const r = 120;
  const ringWidth = 120;

  const statuses = [
    { key: 'connected', color: '#22c55e' },
    { key: 'idle', color: '#facc15' },
    { key: 'off', color: '#ef4444' }
  ];

  const counts = statuses.map(s => devices.filter(d => d.status === s.key).length);
  const total = devices.length || 1;

  // draw filled pie sectors (animated by progress)
  let angleStart = 0;
  statuses.forEach((s, idx) => {
    const pct = counts[idx]/total;
    const fullAngle = pct * 360;
    const angle = fullAngle * progress; // animated portion
    if (pct <= 0) { angleStart += fullAngle; return; }
    const start = angleStart;
    const end = angleStart + angle;
    // draw sector
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    path.setAttribute('d', describeSector(cx, cy, r + ringWidth/2, start, end));
    path.setAttribute('fill', s.color);
    path.setAttribute('opacity', '0.95');
    path.style.cursor = 'pointer';
    // hover effect
    path.addEventListener('mouseenter', () => path.setAttribute('opacity','1'));
    path.addEventListener('mouseleave', () => path.setAttribute('opacity','0.95'));
    path.addEventListener('click', () => {
      // focus first device in this segment
      const gd = devices.find(d => d.status === s.key);
      if (gd) showDevice(gd);
    });
    svg.appendChild(path);

    // label percent at middle of full span (use fullAngle to place percent for readability)
    const mid = start + fullAngle/2;
    const labelPos = polarToCartesian(cx, cy, r - 6, mid);
    const text = document.createElementNS('http://www.w3.org/2000/svg','text');
    text.setAttribute('x', labelPos.x); text.setAttribute('y', labelPos.y);
    // user asked for darker/bolder letters
    text.setAttribute('fill','#000'); text.setAttribute('font-size','12'); text.setAttribute('font-weight','700'); text.setAttribute('text-anchor','middle');
    text.textContent = `${Math.round(pct*100)}%`;
    svg.appendChild(text);

    // place devices for this status evenly within full span (always use full span positions)
    const groupDevices = devices.filter(d => d.status === s.key);
    groupDevices.forEach((d,i) => {
      const slotAngle = start + (fullAngle * (i + 0.5) / Math.max(1, groupDevices.length));
      const nodePos = polarToCartesian(cx, cy, r + ringWidth, slotAngle);
      const node = document.createElementNS('http://www.w3.org/2000/svg','circle');
      node.setAttribute('cx', nodePos.x); node.setAttribute('cy', nodePos.y); node.setAttribute('r', 8);
      node.setAttribute('fill', d.color);
      node.setAttribute('stroke','#000'); node.setAttribute('stroke-width','1');
      node.style.cursor = 'pointer';
      node.addEventListener('click', () => showDevice(d));
      node.addEventListener('mouseenter', () => node.setAttribute('r', 10));
      node.addEventListener('mouseleave', () => node.setAttribute('r', 8));
      svg.appendChild(node);
      const label = document.createElementNS('http://www.w3.org/2000/svg','text');
      const lp = polarToCartesian(cx, cy, r + ringWidth + 28, slotAngle);
      label.setAttribute('x', lp.x); label.setAttribute('y', lp.y);
      label.setAttribute('fill','#000'); label.setAttribute('font-size','12'); label.setAttribute('text-anchor','middle');
      label.textContent = d.name;
      svg.appendChild(label);
    });

    angleStart += fullAngle;
  });

  // center label
  const centerText = document.createElementNS('http://www.w3.org/2000/svg','text');
  centerText.setAttribute('x', cx); centerText.setAttribute('y', cy + 6);
  centerText.setAttribute('fill','#000'); centerText.setAttribute('font-size','18'); centerText.setAttribute('font-weight','700'); centerText.setAttribute('text-anchor','middle');
  centerText.textContent = total + ' Devices';
  svg.appendChild(centerText);
}

// animate chart from 0->1
function animateRadial(duration = 700) {
  const start = performance.now();
  function frame(now) {
    const t = Math.min(1, (now - start) / duration);
    // easeOutCubic
    const p = 1 - Math.pow(1 - t, 3);
    renderRadialChart(p);
    if (t < 1) requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

// initial render and handlers
animateRadial();
window.addEventListener('resize', () => animateRadial(300));
</script>

{% endblock %}